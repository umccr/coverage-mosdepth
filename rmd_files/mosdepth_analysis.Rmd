---
title: "Coverage assessment using mosdepth"
author: "Sehrish Kanwal"
date: "`r format(Sys.time(), '%a %Y-%b-%d')`"
output:
  html_document: 
    keep_md: true
editor_options:
  chunk_output_type: console
---

```{r timecheck, include=FALSE}
NOW <- Sys.time()

#Time chunks during knitting
knitr::knit_hooks$set(timeit = function(before) {
  if(before) {
    print(paste("Start:", Sys.time()))
    NOW <- Sys.time()
  } else {
    print(paste("Stop:", Sys.time()))
    print(Sys.time() - NOW)
  }
})

knitr::opts_chunk$set(
  timeit = TRUE
)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE) # global setup
```

## Required packages

```{r, message=FALSE}
library(knitr)
library(dplyr)
library(kableExtra)
```

```{r}
lf <- function(...) {
  data.frame(fname = list.files(...)) %>% 
    knitr::kable(row.names = TRUE)
}
```

Currently focussing on `regions.bed` file that contains information about coverage of hotspot regions and `quantized.bed` file that contains information about callability windows.

### Hotspot regions

```{r, message=FALSE}
#prepare input data location
mosdepth <- "/Users/kanwals/Documents/UMCCR/data/mosdepth"

#read in sample directory containing mosdepth outputs
mosdepth_output <- file.path(mosdepth, "CCR180136_WH18F001P025_fakeY_changedthreshold/")
#call lf function to list files in the directory
lf(mosdepth_output)

#read regions.bed file - first grep the appropriate bed file from mosdepth sample output folder and then create a path for that name
regions_bed_name <- list.files(mosdepth_output)[grep(".regions.bed.gz$",list.files(mosdepth_output))]

#prepare file path for the regions.bed file
regions_bed_path <- file.path(mosdepth_output, regions_bed_name)
regions_bed <- as.data.frame(read.table(regions_bed_path, header = FALSE, sep = "\t", stringsAsFactors = FALSE))
head(regions_bed)

#read hotspots file - to include the column that shows the change from ref. nucleotide in the regions.bed file
hotspots <- as.data.frame(read.table("~/Documents/UMCCR/data/mosdepth/hotspots/hotspot_fake.bed", header = FALSE, sep = "\t", stringsAsFactors = FALSE))

#merge region_bed file with hotspots column that has info about the possible nucleotide change.Also avoid adding an additional Row.names column by setting it to NULL, The output of this has chr, start, end, ref, cov and alt. Rearrange this output and exclude end (V3) column 
regions_bed_hotspot <- transform(merge(regions_bed, hotspots$V5, by = "row.names", sort = FALSE), Row.names=NULL) %>%
  dplyr::select(V1, V2, V4, y, V5)
#assign column names  
colnames(regions_bed_hotspot) <- c("chrom","pos", "ref", "alt", "cov")
head(regions_bed_hotspot)

#add callability column to regions.bed file - based on the coverage value
call = vector()
call <- sapply(regions_bed_hotspot$cov, function(x){
  if (x == 0)
  {call = c(call, "0")} 
  else if (x >= 1 && x <= 15) 
  {call = c(call, "1:15")}
  else if (x >= 15 && x <= 500) 
  {call = c(call, "15:500")}
  else if (x >= 500) 
  {call = c(call, "500:inf")}
})
regions_bed_new <- dplyr::mutate(regions_bed_hotspot, callability = call)

#present output in a table format - only showing first few entries in the output because the .md file size exceeds github file limit 
head(regions_bed_new) %>%
  kable(caption = "Coverage value and the corresponding callability level for hotspot regions") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
  scroll_box(height = "400px")

#only output loci with zero/low coverage
low_coverage_hotspot <- data.frame()
for (row in 1:nrow(regions_bed_new)){
  if(regions_bed_new[row,6] %in% c("0","1:15")){
    #low_coverage_hotspot <- rbind[low_coverage_hotspot,regions_bed_new[row,]] This throws a stupid error
    low_coverage_hotspot <- dplyr::bind_rows(low_coverage_hotspot,regions_bed_new[row,])
  }
}

#Number of hotspots with zero/low coverage
nrow(low_coverage_hotspot)

#present output in a table format
head(low_coverage_hotspot, 10) %>%
  kable(caption = "Coverage for zero and low callability hotspot regions - only displaying the first few values") %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  scroll_box(height = "400px")
```

## Callability levels

Here, analysing the quantized output produced by mosdepth to see if it adds any extra information.

```{r, message=FALSE}
#read quatized.bed file - first grep the appropriate bed file from folder and then create a path for that name
quantized_bed_name <- list.files(mosdepth_output)[grep(".quantized.bed.gz$",list.files(mosdepth_output))]
quantized_bed_path <- file.path(mosdepth_output, quantized_bed_name)
quantized_bed <- as.data.frame(read.table(quantized_bed_path, header = FALSE, sep = "\t", stringsAsFactors = FALSE))
#assign column names
colnames(quantized_bed) <- c("Chr", "Start", "End", "Callability")
#number of values
nrow(quantized_bed)

#Extract no coverage regions from quantized.bed file
no_coverage <- quantized_bed[quantized_bed$Callability == "0", ]
nrow(no_coverage)
if(nrow(no_coverage) != 0)
  head(no_coverage) %>%
    kable(caption = "No coverage regions - only showing first few values") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)
  
#Extract low coverage regions from quantized.bed file
low_coverage <- quantized_bed[quantized_bed$Callability == "1:15", ]
nrow(low_coverage)
if(nrow(low_coverage) != 0)
  head(low_coverage) %>%
    kable(caption = "Low coverage regions- only showing first few values") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)

#Extract high coverage regions from quantized.bed file
high_coverage <- quantized_bed[quantized_bed$Callability == "500:inf", ]
nrow(high_coverage)
if(nrow(high_coverage) != 0)
  head(high_coverage) %>%
    kable(caption = "High coverage regions- only showing first few values") %>%
    kable_styling(bootstrap_options = "striped", full_width = F)
```



